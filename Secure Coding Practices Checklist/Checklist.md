# Secure Coding Practices
## 1. Input Validation
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 1.1 | Conduct all data validation on a trusted system | Ensure that all data validation is performed on the server, not on the client side. This prevents validation rules from being bypassed by manipulating client-side code. | When a user submits a form, the server checks the input data for validity and rejects it if it doesn't meet the criteria. Client-side JavaScript should not be relied upon for validation. |
| 1.2 | Identify all data sources and classify them | Classify data sources as trusted (e.g., internal databases) or untrusted (e.g., user input, external APIs). Validate all data from untrusted sources to prevent malicious input. | When processing data from user-submitted forms and external APIs, ensure that all input is thoroughly validated, regardless of its source. |
| 1.3 | Centralized input validation routine | Implement a centralized input validation routine to ensure consistent and thorough validation across the application. | Create a single validation function that is called for all user input, ensuring that every input is consistently validated according to predefined rules. |
| 1.4 | Specify proper character sets | Define a consistent character set, such as UTF-8, for all sources of input to avoid encoding mismatches and potential security vulnerabilities. | Ensure that all data, regardless of its source, is consistently encoded using UTF-8 to prevent encoding-related issues. |
| 1.5 | Encode data to a common character set | Convert data to a common character set (e.g., UTF-8) before validation to ensure consistent handling and prevent encoding-based attacks. | Before validating user input, convert it to UTF-8 to standardize character encoding. |
| 1.6 | All validation failures result in input rejection | Upon validation failure, reject the input and prevent further processing. This prevents malicious data from entering the system. | If a user submits invalid input, the system should reject it and not proceed with any further actions. |
| 1.7 | Determine system support for UTF-8 extended character sets | Determine if the system supports UTF-8 extended character sets. If supported, validate input after UTF-8 decoding is completed. | If the application supports extended character sets, ensure that validation occurs after decoding, addressing potential encoding-related vulnerabilities. |
| 1.8 | Validate all client-provided data | Validate all input from the client, including parameters, URLs, HTTP headers, and automated postbacks, to prevent malicious code injection. | When processing data from client-side sources, such as form submissions and HTTP headers, validate it rigorously to avoid code injection vulnerabilities. |
| 1.9 | Verify header values contain only ASCII characters | Ensure that header values in both requests and responses contain only ASCII characters to prevent potential attacks exploiting character encoding differences. | Check that header values are limited to ASCII characters to prevent security issues stemming from character encoding variations. |
| 1.10 | Validate data from redirects | Validate data from redirects to prevent malicious content from being directly submitted to the redirect target, bypassing application logic. | When handling data from redirects, ensure that it is validated to prevent security bypasses. |
| 1.11 | Validate for expected data types | Verify that input matches the expected data type, such as integer, string, or date, to prevent type-related errors and potential vulnerabilities. | Check that input is of the correct data type to avoid errors and security issues caused by data type mismatches. |
| 1.12 | Validate data range | Check that input values fall within the expected range to prevent overflow or underflow conditions that could lead to vulnerabilities. | Ensure that input values are within specified ranges to prevent security issues related to data overflow or underflow. |
| 1.13 | Validate data length | Limit the length of input to prevent buffer overflows and other length-based attacks. | Restrict the length of input data to mitigate security risks associated with buffer overflows and other length-based vulnerabilities. |
| 1.14 | Validate all input against a "white" list | Whenever possible, validate input against a whitelist of allowed characters to restrict the range of acceptable input and prevent malicious code injection. | Ensure that input is validated against a predefined whitelist of permissible characters to minimize security risks. |
| 1.15 | Handle hazardous characters | If potentially hazardous characters must be allowed as input, implement additional controls like output encoding and secure APIs. | If your application requires the use of hazardous characters, apply additional security measures like output encoding and secure APIs to mitigate potential risks. |
| 1.16 | Check specific inputs | If standard validation fails, check for specific problematic characters, including null bytes (%00), new line characters (%0d, %0a, \r, \n), path alteration characters (../ or ..\), and alternate representations of hazardous characters. | If standard validation doesn't catch certain inputs, inspect for problematic characters like null bytes, new line characters, path alteration sequences, or alternate encodings of hazardous characters. |

<br><br>
## 2. Output Encoding 
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 2.1 | Conduct all encoding on a trusted system | Ensure that all encoding of output data is performed on the server, not on the client side, to prevent tampering and security vulnerabilities. | When generating HTML for a web page, the server should encode special characters to prevent cross-site scripting (XSS) vulnerabilities. |
| 2.2 | Utilize a standard, tested routine for each type of outbound encoding | Employ well-tested and standardized encoding routines for different data types, such as HTML entity encoding, to ensure consistent and secure encoding. | Use a trusted library or built-in functions for encoding data, such as HTML entity encoding for web content. |
| 2.3 | Contextually output encode all data returned to the client | Apply output encoding to all data that originates outside the application's trust boundary and is returned to the client. Use appropriate encoding based on the context. | When displaying user-generated content on a web page, use HTML entity encoding to prevent HTML injection. |
| 2.4 | Encode all characters unless they are known to be safe | Encode all characters in output data unless they are explicitly known to be safe for the intended interpreter to prevent malicious code injection or data manipulation. | Encode special characters like "<" and ">" in user-generated content to prevent XSS attacks. |
| 2.5 | Contextually sanitize output of untrusted data to queries | Sanitize all output of untrusted data to prevent injection attacks in queries for SQL, XML, and LDAP. Apply contextual sanitation based on the query type. | When constructing an SQL query from user input, sanitize the input to prevent SQL injection, ensuring that the user input doesn't contain harmful SQL commands. |
| 2.6 | Sanitize output of untrusted data to operating system commands | Sanitize all output of untrusted data before incorporating it into operating system commands to prevent malicious code execution or system compromise. | When executing shell commands with user input, sanitize the input to ensure that it doesn't contain harmful commands that could compromise the system. |

<br><br>
## 3. Authentication and Password Management
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 3.1 | Require authentication for all pages and resources | Ensure that authentication is required for all pages and resources, except those specifically intended to be public. | All users accessing the application should be required to authenticate themselves, except for publicly accessible information like a homepage. |
| 3.2 | Enforce all authentication controls on a trusted system | Implement all authentication controls on the server, not on the client side, to prevent tampering with authentication logic. | Authentication checks should be performed on the server to ensure the security of the process. |
| 3.3 | Establish and use standard, tested authentication services | Utilize established and tested authentication services whenever possible, such as Google Sign-In or OAuth, to simplify secure authentication. | Implementing authentication through widely recognized and tested services like Google Sign-In enhances security and user experience. |
| 3.4 | Use a centralized implementation for all authentication controls | Implement a centralized authentication mechanism for all authentication-related processes, providing a single point of control for managing user credentials and access permissions. | Authentication should be handled through a centralized system that manages user credentials and permissions. |
| 3.5 | Segregate authentication logic from requested resources | Separate authentication logic from the resource being requested and use redirection to and from the centralized authentication control to ensure security. | Authentication processes should not be mixed with resource processing, and redirection to a centralized authentication control should be used. |
| 3.6 | Ensure secure failure of authentication controls | Authentication controls should fail securely, with responses not revealing which part of the authentication data was incorrect. | If authentication fails, the system should provide a generic message like "Invalid username and/or password" without indicating which part of the authentication data was incorrect. |
| 3.7 | Secure administrative and account management functions | Apply the same level of security controls to administrative and account management functions as to the primary authentication mechanism to ensure consistent security. | Administrative actions and account management should have the same level of security as user authentication. |
| 3.8 | Secure storage of password hashes | If the application manages a credential store, ensure that only cryptographically strong one-way salted hashes of passwords are stored. The table/file storing the passwords and keys should be writable only by the application. | Passwords should be stored securely using strong hashing algorithms, and access to the storage should be tightly controlled. |
| 3.9 | Implement password hashing on a trusted system | Perform password hashing on the server, not on the client side, to protect the hashing algorithm and salt values from exposure. | Password hashing should occur on the server to maintain the security of the hashing process. |
| 3.10 | Validate authentication data after all data input | Validate the authentication data only after all data input is complete, especially for sequential authentication implementations. | In a multi-step authentication process, data should be validated only after all steps are completed. |
| 3.11 | Secure authentication failure responses | Authentication failure responses should not indicate which part of the authentication data was incorrect. | Error responses in case of authentication failure should provide the same message, such as "Invalid username and/or password," without specifying the exact error. |
| 3.12 | Use authentication for connections to external systems | Utilize authentication for connections to external systems involving sensitive information or functions. | When accessing external systems with sensitive data, ensure that authentication is required to establish secure connections. |
| 3.13 | Encrypt and store external authentication credentials | Authentication credentials for accessing services external to the application should be encrypted and stored in a protected location on a trusted system, not in the source code. | External service credentials should be securely stored and not kept in the application's source code. |
| 3.14 | Use only HTTP POST requests for authentication credentials | Transmit authentication credentials using only HTTP POST requests to prevent exposure in URL parameters, which can be easily intercepted. | User credentials should be sent using HTTP POST requests to avoid exposing them in URLs. |
| 3.15 | Send non-temporary passwords over encrypted connections | Only send non-temporary passwords over encrypted connections or as encrypted data to protect them from interception. | Non-temporary passwords should be transmitted securely to prevent eavesdropping. |
| 3.16 | Enforce password complexity requirements | Enforce password complexity requirements based on policy or regulations to enhance password security. | Passwords should meet complexity requirements, such as including alphabetic, numeric, and special characters. |
| 3.17 | Enforce password length requirements | Enforce password length requirements based on policy or regulations to ensure stronger passwords. | Passwords should meet length requirements, which may include a minimum length of eight characters or more. |
| 3.18 | Obscure password entry on the user's screen | Password entry should be obscured on the user's screen, using input type "password" on web forms. | When users enter passwords, the input should be masked to prevent visual observation. |
| 3.19 | Enforce account disabling after invalid login attempts | Implement account disabling after a set number of invalid login attempts to deter brute force attacks. | After a specified number of failed login attempts, user accounts should be temporarily disabled. |
| 3.20 | Secure password reset and change operations | Password reset and change operations should have the same level of security controls as account creation and authentication. | The processes for resetting and changing passwords should be as secure as initial account creation and authentication. |
| 3.21 | Use random security questions | Password reset questions should support sufficiently random answers to enhance security. | Instead of using easily guessable questions like "favorite book," use questions that have less predictable answers. |
| 3.22 | Send reset information to pre-registered email addresses | If using email-based resets, only send email to pre-registered addresses with a temporary link or password. | When resetting passwords via email, send reset information only to email addresses that are pre-registered by the user. |
| 3.23 | Set short expiration times for temporary passwords | Temporary passwords and links should have a short expiration time to reduce the risk of unauthorized access if they are compromised. | Temporary passwords should only be valid for a short period, such as 24 hours. |
| 3.24 | Enforce changing of temporary passwords on first use | Require users to change temporary passwords immediately upon first use to prevent prolonged use of insecure temporary passwords. | Users should be prompted to change temporary passwords the first time they log in. |
| 3.25 | Notify users of password resets | Inform users when a password reset occurs to alert them of potential unauthorized access. | Users should receive notifications when their passwords are reset to keep them informed about security events. |
| 3.26 | Prevent password re-use | Implement mechanisms to discourage users from reusing old passwords to promote stronger and unique passwords. | Users should be prevented from using their old passwords when creating new ones. |
| 3.27 | Enforce a waiting period for password changes | Implement a delay between password creation and the first password change to prevent attackers from immediately changing the password. | Users should not be allowed to change their password immediately after creating it. |
| 3.28 | Enforce periodic password changes | Implement a policy requiring periodic password changes, with the time between resets being administratively controlled. | Passwords should be changed at regular intervals as specified by the policy. |
| 3.29 | Disable "remember me" functionality for password fields | Disable the "remember me" option for password fields, especially on public or shared devices to enhance security. | Users should not be given the option to have their password remembered on public or shared devices. |
| 3.30 | Report last account activity to users | Notify users of the last successful or unsuccessful login attempt to keep them informed about account activity. | Users should be aware of the last login attempts to detect any suspicious activity. |
| 3.31 | Implement monitoring for multi-account attacks | Monitor and identify attacks against multiple user accounts using the same password, a common pattern used to bypass standard lockouts. | The system should detect and prevent attacks where multiple accounts are targeted using the same password. |
| 3.32 | Change default passwords and user IDs | Change all vendor-supplied default passwords and user IDs or disable the associated accounts to prevent unauthorized access. | Vendor-supplied default credentials should be replaced or disabled to prevent unauthorized access. |
| 3.33 | Re-authenticate users before critical operations | Require users to re-authenticate before performing critical operations, adding an extra layer of security for sensitive actions. | Users should re-enter their credentials before performing critical operations like changing account settings. |
| 3.34 | Implement Multi-Factor Authentication for sensitive accounts | Use Multi-Factor Authentication (MFA) for highly sensitive or high-value transactional accounts to add an additional layer of security. | For highly sensitive accounts, require MFA to verify the user's identity. |
| 3.35 | Inspect third-party authentication code | If using third-party code for authentication, inspect the code carefully to ensure it is not affected by any malicious code. | When using third-party authentication code, thoroughly review it to check for vulnerabilities or malicious code. |

<br><br>
## 4. Session Management
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 4.1 | Use Server or Framework Session Management | Utilize the built-in session management provided by your web server or framework. This ensures that your application recognizes and uses valid session identifiers. | If you're using a web framework like Express.js in Node.js, use its session management features. |
| 4.2 | Create Session Identifiers on a Trusted System | Generate session identifiers (like cookies) on the server to prevent tampering. | When a user logs in, the server generates a unique session ID and sends it to the user's browser. |
| 4.3 | Use Secure Session Algorithms | Choose strong, secure algorithms for generating session identifiers. They should be random and unpredictable. | Instead of using a simple incremental number, use a cryptographically secure random string as the session identifier. |
| 4.4 | Set Domain and Path for Cookies | Limit where cookies with session IDs can be used by setting their domain and path. | If your site is "example.com," restrict the cookie's domain to ".example.com" to prevent it from being used on other subdomains. |
| 4.5 | Properly Terminate Sessions on Logout | Ensure that the logout function fully terminates the user's session or connection. | When a user clicks "Logout," their session is invalidated, and they are redirected to the login page. |
| 4.6 | Accessible Logout | Provide a logout option on all pages protected by authorization, so users can easily log out. | Include a "Logout" link in the navigation menu on every page. |
| 4.7 | Session Timeout | Set a short session inactivity timeout, usually a few hours, to balance security and user convenience. | Automatically log the user out after 15 minutes of inactivity. |
| 4.8 | Avoid Persistent Logins | Do not allow users to stay logged in indefinitely. Log them out periodically, even during an active session. | Prompt the user to re-enter their password after a set time, even if they are actively using the app. |
| 4.9 | Close Old Session on Login | If a user had a session before login, close that session and create a new one after successful login. | When a user logs in, their previous session becomes invalid. |
| 4.10 | Generate New Session Identifier on Re-authentication | Whenever a user re-authenticates (e.g., changing their password), generate a new session identifier. | When a user updates their password, their session ID changes. |
| 4.11 | No Concurrent Logins with the Same User ID | Prevent multiple simultaneous logins with the same user ID. | If a user is already logged in and tries to log in again from a different device, the previous session is invalidated. |
| 4.12 | Hide Session Identifiers | Do not expose session identifiers in URLs, error messages, or logs. Store them securely in the HTTP cookie header. | Avoid displaying session IDs in the URL like "example.com?session=12345." |
| 4.13 | Protect Server-Side Session Data | Implement access controls on the server to prevent unauthorized access to session data by other users or processes on the server. | Only authorized server-side code can access and modify session data. |
| 4.14 | Rotate Session Identifiers | Periodically generate new session identifiers and deactivate the old ones. This prevents session hijacking if the original identifier was compromised. | Every hour, generate a new session ID and invalidate the previous one. |
| 4.15 | Switch to HTTPS | Change the session identifier if the connection security switches from HTTP to HTTPS. Maintain HTTPS consistently within your application. | If a user logs in via an insecure HTTP connection, generate a new session ID when they switch to a secure HTTPS connection. |
| 4.16 | Use Strong Tokens for Sensitive Operations | For sensitive server-side actions (e.g., account management), use strong random tokens or parameters to prevent Cross-Site Request Forgery (CSRF) attacks. | When a user requests to change their password, generate a unique token to ensure the request is legitimate. |
| 4.17 | Use Strong Tokens for Critical Operations | For highly sensitive or critical operations, use per-request, rather than per-session, strong random tokens or parameters. | When processing a financial transaction, generate a unique token for each step of the transaction. |
| 4.18 | Set "Secure" Attribute for Cookies | Mark cookies as "secure" when transmitted over a TLS (HTTPS) connection to prevent interception. | Ensure that cookies carrying session information are marked as "secure" to be transmitted only over secure HTTPS connections. |
| 4.19 | Use HttpOnly for Cookies | Set cookies with the HttpOnly attribute unless you specifically need client-side scripts to read or set a cookie's value. | Use HttpOnly to prevent client-side scripts from accessing cookies containing sensitive session information. |

<br><br>
## 5. Access Control
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 5.1 | Use only trusted system objects for access authorization | Use only trusted system objects, such as server-side session objects, for making access authorization decisions. | Access authorization decisions should be based on information from trusted sources within the application. |
| 5.2 | Implement a single site-wide component for access authorization | Use a single site-wide component to check access authorization, including libraries that call external authorization services. | Access to resources should be controlled consistently through a central component. |
| 5.3 | Secure failure of access controls | Access controls should fail securely, ensuring that unauthorized users cannot gain access to restricted resources. | If a user is not authorized to access a resource, they should not be able to bypass the access control mechanism. |
| 5.4 | Deny all access if security configuration information is unavailable | Deny all access if the application cannot access its security configuration information, ensuring that security settings are enforced even when configuration data is inaccessible. | If the application is unable to access its security configuration, it should default to denying access. |
| 5.5 | Enforce authorization controls on every request | Enforce authorization controls on every request, including those made by server-side scripts, "includes," and requests from rich client-side technologies like AJAX and Flash. | Authorization checks should be consistently applied to all types of requests. |
| 5.6 | Segregate privileged logic from other application code | Segregate privileged logic from other application code to prevent unauthorized access to sensitive operations. | Critical functionality that requires elevated permissions should be isolated from regular application code. |
| 5.7 | Restrict access to files and resources to authorized users | Restrict access to files and resources, including those outside the application's control, to only authorized users. | Only users with the appropriate permissions should be able to access files and resources. |
| 5.8 | Restrict access to protected URLs to authorized users | Ensure that access to protected URLs is restricted to only authorized users. | Users should be required to authenticate before accessing protected URLs. |
| 5.9 | Restrict access to protected functions to authorized users | Restrict access to protected functions to only authorized users. | Only users with proper permissions should be able to execute protected functions. |
| 5.10 | Restrict direct object references to authorized users | Limit access to direct object references to only authorized users. | Users should not be able to access objects directly if they are not authorized. |
| 5.11 | Restrict access to services to authorized users | Ensure that access to services is restricted to only authorized users. | Services should not be accessible to unauthorized users. |
| 5.12 | Restrict access to application data to authorized users | Limit access to application data to only authorized users. | Users should have access only to the data they are authorized to see or modify. |
| 5.13 | Restrict access to user and data attributes to authorized users | Control access to user and data attributes and policy information by authorized users. | User attributes and sensitive data should be restricted to authorized users. |
| 5.14 | Restrict access to security-relevant configuration information | Limit access to security-relevant configuration information to authorized users. | Configuration settings related to security should not be accessible to unauthorized users. |
| 5.15 | Ensure consistency between server-side access control rules | Ensure that server-side implementation and presentation layer representations of access control rules match. | Access control rules should be consistent between server-side implementation and the presentation layer. |
| 5.16 | Use encryption and integrity checking for client-stored state data | If state data must be stored on the client, use encryption and integrity checking on the server side to prevent tampering. | State data stored on the client side should be encrypted and protected to prevent unauthorized modifications. |
| 5.17 | Enforce compliance with business rules in application logic flows | Enforce application logic flows to comply with business rules, ensuring that application behavior aligns with business requirements. | Application logic should adhere to business rules to maintain consistency and security. |
| 5.18 | Limit the number of transactions per user or device | Limit the number of transactions a single user or device can perform within a given period to deter automated attacks. | Implement transaction limits to prevent abuse by automated systems or malicious users. |
| 5.19 | Use the "referer" header as a supplemental check | Use the "referer" header as a supplemental check, but not as the sole authorization check, as it can be spoofed. | The "referer" header can be used as an additional security measure but should not be the only means of authorization. |
| 5.20 | Periodically re-validate user authorization | If long authenticated sessions are allowed, periodically re-validate a user's authorization to ensure their privileges have not changed. Log the user out and force re-authentication if necessary. | Users with long sessions should have their authorization periodically re-validated to ensure that their privileges have not changed. |
| 5.21 | Implement account auditing and disabling of unused accounts | Implement account auditing and enforce the disabling of unused accounts, such as after 30 days from the expiration of an account's password. | Accounts that are not actively used should be disabled or removed to maintain security. |
| 5.22 | Support disabling of accounts and session termination | The application must support disabling of accounts and terminating sessions when authorization ceases, such as changes to roles, employment status, or business processes. | Accounts and sessions should be disabled when users no longer have authorization, such as when they change roles or leave the organization. |
| 5.23 | Assign least privilege to service accounts | Service accounts or accounts used for connections to external systems should have the least privilege necessary. | Service accounts should have only the permissions required for their specific tasks. |
| 5.24 | Create an Access Control Policy to document access criteria | Create an Access Control Policy to document an application's business rules, data types, and access authorization criteria or processes to ensure proper access provisioning and control. | An Access Control Policy should outline the access requirements for data and system resources, defining who can access what and under what conditions. |

<br><br>
## 6. Cryptographic Practices
| No | Test Case | Scenario | Example |
|---|---|---|---|
| 6.1 | Implement cryptographic functions on a trusted system | All cryptographic functions used to protect secrets from the application user must be implemented on a trusted system, such as the server. | Cryptographic operations should be performed on a trusted server rather than on the client side to prevent potential security risks. |
| 6.2 | Protect master secrets from unauthorized access | Protect master secrets used in cryptographic operations from unauthorized access, ensuring they are not exposed to potential attackers. | Sensitive cryptographic keys and master secrets should be securely stored and protected against unauthorized access. |
| 6.3 | Ensure cryptographic modules fail securely | Cryptographic modules should fail securely to prevent potential security vulnerabilities in case of errors or attacks. | Cryptographic modules should be designed to handle errors or attacks in a way that doesn't compromise security. |
| 6.4 | Use approved random number generators for un-guessable values | All random numbers, random file names, random GUIDs, and random strings should be generated using the cryptographic module's approved random number generator when these random values are intended to be un-guessable. | To create unpredictable values, use approved cryptographic random number generators rather than relying on standard random functions. |
| 6.5 | Comply with cryptographic standards | Cryptographic modules used by the application should be compliant with standards such as FIPS 140-2 or an equivalent standard. | Cryptographic modules should meet established security standards to ensure their reliability and security. |
| 6.6 | Implement key management policies and processes | Establish and utilize a policy and process for how cryptographic keys will be managed to maintain the security and integrity of cryptographic operations. | Clearly defined policies and processes for managing cryptographic keys should be in place to ensure their proper use and security. |

<br><br>
## 7. Error Handling and Logging
